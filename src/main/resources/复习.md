#### 集合
1. 线程安全的集合
   1. ConcurrentHashMap
      1. 保证多线程的方式：使用cas+synchronized对单节点进行加锁
      2. 分桶加锁，只锁部分
2. 非线程安全的集合
   1. HashMap
      1. 底层实现：数组加（链表-红黑树）
      2. 树的转换，阈值log(n)，n，8
      3. 扩容：判断是否达到临界值达到则不扩容，未达到则扩容，扩容之后将原有数据移动到新的table中
3. fai-fast
   1. 在遍历时，如果容器元素被修改，就会报ConcurrentModificationException异常，并终止遍历
   2. modCount：记录容器被修改次数，使用迭代器迭代时，modCount会被赋值给exceptedModCount
4. fial-safe
   1. 支持在遍历时修改元素
   2. copOnWriteArrayList
#### jvm
1. java内存区域
   1. 堆：存放对象实例
   2. 栈：虚拟机栈、本地方法栈
   3. 方法区：存放已被虚拟机加载的类型信息、常量、静态变量
   4. 运行常量池
   5. 程序计数器
2. 分配内存的方式
   1. 指针碰撞
   2. 空闲列表
3. 对象创建
   1. 接收new指令，常量池判断是否已经初始化
   2. 执行类加载过程
      1. 加载：根据类的全限定名获取二进制流，将二进制流中的静态存储结构转换为运行时存储结构，生成class对象，作为类数据访问入口
      2. 验证：文件格式验证、元数据验证、字节码验证、符号引用验证
      3. 准备：为静态变量分配内存并进行初始化
      4. 解析：符号引用转换为直接引用
      5. 初始化
   3. 分配内存空间
   4. 初始化内存空间，值为0
   5. 设置对象相关信息
   6. 调用java构造方法进行资源填充
4. 垃圾回收算法
   1. 标记清除
   2. 标记整理
   3. 复制算法
   4. 分代收集
5. 垃圾回收器
   1. Serial：单线程新生代复制算法
   2. Serial Old：单线程老年代标记整理
   3. ParNew：多线程复制算法
   4. Parallel Scavenge：多线程复制算法，追求高吞吐量
   5. Parallel Old：parallel scavenge 老年代多线程标记整理算法
   6. CMS:标记清除
      1. 初始标记，STW
      2. 并发标记
      3. 重新标记
      4. 并发清除
      5. 问题：浮动垃圾、CPU敏感、浮动垃圾
   7. G1
      1. 初始标记
      2. 并发标记
      3. 最终标记
      4. 筛选回收
   8. ZGC
6. TODO JVM调优
#####  动态代理
1. jdk动态代理
   1. 设置需要代理的接口和实现类
   2. 创建代理类，实现InvocationHandler中的Invoke方法
   3. 通过Proxy.newProxyInstance(对象类加载器，对象所有接口，实现代理接口的类)构建基于需要代理类的新实例
   4. 调用方法
   5. 原理：实现被代理类的接口来完成动态代理，使用反射机制
2. cglib动态代理
   1. 创建需要代理的对象
   2. 创建拦截类实现MethodInterceptor
   3. 调用拦截类构造方法，传入代理对象(构建Enhancer对象，传入代理类的class对象，设置回调方法为拦截实例，创建实例)
   4. 执行方法
   5. 原理：通过修改字节码生成新的代理类来实现动态代理，使用过fastclass，final方法不能代理
#### 锁
1. synchronized
2. 可重入锁和不可重入锁
3. 悲观锁和乐观锁
4. 公平锁和非公平锁
5. 自旋锁与自适应锁
6. AQS
   - FairSync
   ![image-20221103151849814](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\fairsync.png)
   - NonfairSync
   ![image-20221103152034843](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\nofairsync.png)
   - 公平锁和非公平锁的尝试加锁的差异在于是否需要加入队列，其余实现基本一致，这也是二者之间的区别，非公平锁先拿先得公平锁则依赖于队列来维持加锁的顺序
7. 锁升级
   1. synchronized中有一个mark word会随着锁的状态变化而变化
   2. synchronized中EntryList，线程尝试获取锁时，如果锁已被占用，这个线程会被包装成ObjectWaiter插入到cxq中，当持有锁线程释放锁时，会将cxq中所有元素移到EntryList，并唤醒EntryList队首线程
8. 死锁
9. 多线程循环打印ABC
   1. 使用锁：循环内部加锁，直接进行判断，满足条件的打印，设置全局变量
   2. 使用锁：循环外部加锁，设置唤醒时机，不满足的继续等待
   3. 信号量：保证同一时间只有一个线程可以执行，那么当前这个线程的信号量为1，执行完成之后释放当前线程信号量，指定下一个需要执行的信号量为1

#### spring
1. bean的生命周期
   1. spring在启动时通过注解或者xml文件扫描需要被spring管理的bean，将这些信息封装成beandefiniition，最后将这些信息放置在beanDefinitionMap中，key是beanName,value是beanDefinition
   2. 遍历beanDefinitionMap，执行BeanFactoryPostProcessor这个bean工厂后置处理逻辑
   3. 使用反射实例化对象
   4. 注入相关属性-依赖注入
   5. 是否实现aware接口，如果实现则填充相关资源
   5. 销毁实例
2. 使用三级缓存解决循环依赖问题
   1. 一级缓存，正式对象
   2. 二级缓存，半成品对象
   3. 三级缓存，工厂
3. 设计模式
   1. 代理模式：AOP
   2. 策略模式：AOP依据不同的场景使用不同的设计模式，DefaultAopProxyFactory中createAopProxy()函数
   3. 装饰器模式：spring事务
   4. 单例模式
   5. 简单工厂模式：beanFactory,由工厂进行所有逻辑判断、实例创建，利用反射
   6. 工厂方法模式：factoryBean，不同工厂生产不同产品
   7. 观察者模式：事件
      - 观察者模式和发布订阅模式区别：是否有中间Broker处理发布内容，前者是松耦合，后者是完全解耦
   8. 模板模式
   9. 适配器模式