####  集合
##### 线程安全的集合
   1. ConcurrentHashMap
      1. 保证多线程的方式：使用cas+synchronized对单节点进行加锁
      2. 分桶加锁，只锁部分
##### 非线程安全的集合
   1. HashMap
      1. 底层实现：数组加（链表-红黑树）
      2. 树的转换，阈值log(n)，n，8
      3. 扩容：判断是否达到临界值达到则不扩容，未达到则扩容，扩容之后将原有数据移动到新的table中
3. fai-fast
   1. 在遍历时，如果容器元素被修改，就会报ConcurrentModificationException异常，并终止遍历
   2. modCount：记录容器被修改次数，使用迭代器迭代时，modCount会被赋值给exceptedModCount
4. fial-safe
   1. 支持在遍历时修改元素
   2. copOnWriteArrayList
#### jvm
##### java内存区域
   1. 堆：存放对象实例
   2. 栈：虚拟机栈、本地方法栈
   3. 方法区：存放已被虚拟机加载的类型信息、常量、静态变量
   4. 运行常量池
   5. 程序计数器
##### 分配内存的方式
   1. 指针碰撞
   2. 空闲列表
##### 对象创建
   1. 接收new指令，常量池判断是否已经初始化
   2. 执行类加载过程
      1. 加载：根据类的全限定名获取二进制流，将二进制流中的静态存储结构转换为运行时存储结构，生成class对象，作为类数据访问入口
      2. 验证：文件格式验证、元数据验证、字节码验证、符号引用验证
      3. 准备：为静态变量分配内存并进行初始化
      4. 解析：符号引用转换为直接引用
      5. 初始化
   3. 分配内存空间
   4. 初始化内存空间，值为0
   5. 设置对象相关信息
   6. 调用java构造方法进行资源填充
##### 垃圾回收算法
   1. 标记清除
   2. 标记整理
   3. 复制算法
   4. 分代收集
##### 垃圾回收器
   1. Serial：单线程新生代复制算法
   2. Serial Old：单线程老年代标记整理
   3. ParNew：多线程复制算法
   4. Parallel Scavenge：多线程复制算法，追求高吞吐量
   5. Parallel Old：parallel scavenge 老年代多线程标记整理算法
   6. CMS:标记清除
      1. 初始标记，STW
      2. 并发标记
      3. 重新标记
      4. 并发清除
      5. 问题：浮动垃圾、CPU敏感、浮动垃圾
   7. G1
      1. 初始标记
      2. 并发标记
      3. 最终标记
      4. 筛选回收
   8. ZGC
##### TODO JVM调优
#### java基础
#####  动态代理
1. jdk动态代理
   1. 设置需要代理的接口和实现类
   2. 创建代理类，实现InvocationHandler中的Invoke方法
   3. 通过Proxy.newProxyInstance(对象类加载器，对象所有接口，实现代理接口的类)构建基于需要代理类的新实例
   4. 调用方法
   5. 原理：实现被代理类的接口来完成动态代理，使用反射机制
2. cglib动态代理
   1. 创建需要代理的对象
   2. 创建拦截类实现MethodInterceptor
   3. 调用拦截类构造方法，传入代理对象(构建Enhancer对象，传入代理类的class对象，设置回调方法为拦截实例，创建实例)
   4. 执行方法
   5. 原理：通过修改字节码生成新的代理类来实现动态代理，使用过fastclass，final方法不能代理
##### java对象构成
1. 对象头
   1. Mark Word（标记字段）：
      1. 用于存储对象的hashcode、GC分代情况、锁状态信息
   2. Klass Point（类型指针）
2. 实例数据
3. 对其填充
#### 锁
##### synchronized
1. 作用于静态方法，锁的是当前class对象
2. 修饰代码块，指定加锁对象给对象加锁
3. 修饰实例方法，给当前实例对象this加锁
4. MoniterEnter和MoniterExit对应同步块的进入和退出
5. ACC_SYNCHRONIZED关键字用于标记，是否需要获取锁（用在方法中flag）
6. 重量级锁的状态下（Synchronized为重量级锁），对象头指向堆中的monitor
7. 一个monitor对象包含cxq(下图中的ContentList),EntryList,WaitSet,owner
8. **当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。
    如果一个线程在同步块中调用了Object#wait方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。**
![img](images/monitor.webp)
##### 可重入锁和不可重入锁
##### 悲观锁和乐观锁
##### 公平锁和非公平锁
1. 公平锁遵循队列原则，按照排队顺序获取锁
2. 非公平锁则不按顺序，谁抢到就是谁的
##### 自旋锁与自适应锁
- 自旋锁
   1. 多核机器中，多个程序并行执行，如果当请求线程没有拿到锁，不挂起线程而是继续占用处理器时间，不断判断是否可以拿到锁
   2. 优点：不会发生线程切换，不会进入阻塞状态，减少了不必要的上下文切换，提高效率
   3. 缺点：长时间进入自旋，消耗CPU，使用不当会造成CPU使用率极高，属于不公平的锁，有可能造成线程饥饿
- 自适应锁：针对自旋锁的不足，如果一个线程在上一次执行过程中自旋成功，那么就会增加自旋次数，反之则会减少甚至省略掉自旋过程
##### AQS
   - FairSync
      ![image-20221103151849814](images\fairsync.png)
   - NonfairSync
      ![image-20221103152034843](images\nofairsync.png)
   - 公平锁和非公平锁的尝试加锁的差异在于是否需要加入队列，其余实现基本一致，这也是二者之间的区别，非公平锁先拿先得公平锁则依赖于队列来维持加锁的顺序
##### 锁升级
   1. synchronized中有一个mark word会随着锁的状态变化而变化
   2. synchronized中EntryList，线程尝试获取锁时，如果锁已被占用，这个线程会被包装成ObjectWaiter插入到cxq中，当持有锁线程释放锁时，会将cxq中所有元素移到EntryList，并唤醒EntryList队首线程
##### 死锁
##### 多线程循环打印ABC
   1. 使用锁：循环内部加锁，直接进行判断，满足条件的打印，设置全局变量
   2. 使用锁：循环外部加锁，设置唤醒时机，不满足的继续等待
   3. 信号量：保证同一时间只有一个线程可以执行，那么当前这个线程的信号量为1，执行完成之后释放当前线程信号量，指定下一个需要执行的信号量为1

#### spring
##### bean的生命周期
   1. spring在启动时通过注解或者xml文件扫描需要被spring管理的bean，将这些信息封装成beandefiniition，最后将这些信息放置在beanDefinitionMap中，key是beanName,value是beanDefinition
   2. 遍历beanDefinitionMap，执行BeanFactoryPostProcessor这个bean工厂后置处理逻辑
   3. 使用反射实例化对象
   4. 注入相关属性-依赖注入
   5. 是否实现aware接口，如果实现则填充相关资源
   6. 销毁实例
   7. ![img_1.png](images/img_1.png)
##### 使用三级缓存解决循环依赖问题
   1. 一级缓存，正式对象
   2. 二级缓存，半成品对象
   3. 三级缓存，工厂
##### 设计模式
   1. 代理模式：AOP
   2. 策略模式：AOP依据不同的场景使用不同的设计模式，DefaultAopProxyFactory中createAopProxy()函数
   3. 装饰器模式：spring事务
   4. 单例模式
   5. 简单工厂模式：beanFactory,由工厂进行所有逻辑判断、实例创建，利用反射
   6. 工厂方法模式：factoryBean，不同工厂生产不同产品
   7. 观察者模式：事件
      - 观察者模式和发布订阅模式区别：是否有中间Broker处理发布内容，前者是松耦合，后者是完全解耦
   8. 模板模式
   9. 适配器模式

##### beanfactory和factorybean
1. spring最基础bean工厂，提供了管理bean的通用方法如getBean(),containsBean()
2. factoryBean是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例
3. 一个bean A实现了factoryBean，那么A就变成一个工厂了，根据A名称获取到的实例实际上是由工厂得getObject构建的，如果想调用自己的构造方法，那么需要在前面加上&
4. factoryBean应用：创建AOP的代理对象
5. beanFactory是spring容器顶层接口，factoryBean是用户自定义工厂接口

